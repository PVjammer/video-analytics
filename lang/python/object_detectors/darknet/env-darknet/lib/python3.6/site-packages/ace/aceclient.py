#!/bin/python3
# import ansyncio
import cv2
import grpc
import click
import os.path
import requests
import sys
import time
import threading
from influxdb import InfluxDBClient

import logging

from google.protobuf import json_format
from ace import analytic_pb2, analytic_pb2_grpc, analyticservice
# import analytic_pb2, analytic_pb2_grpc, analyticservice

class AceClient:
    def __init__(self):
        self.a_client = None
        self.server = None
        self.proxyclient = None

class ProxyClient:
    def __init__(self, host="localhost", port="3000"):
        self.addr = "http://{!s}:{!s}/update".format(host, port)

    def update(self, **kwargs):
        r = requests.post(self.addr, json=kwargs)
        results = {"status":{
                    "code": r.status_code
                }
        }
        if r.status_code == requests.codes.ok:
            results["status"]["msg"] = r.reason
        print(results)

class AnalyticClient(analytic_pb2_grpc.AnalyticStub):
    """Client for talking directly to a single ACE analytic"""
    def __init__(self, addr="localhost:50051"):
        self.addr = addr
        channel = grpc.insecure_channel(self.addr)
        super(AnalyticClient, self).__init__(channel)

    def process_frame(self, frame, frame_meta=None):
        """Receive a video frame (numpy array) and send as bytes to an analytic"""
        req = analytic_pb2.InputFrame()
        try:
            # Added try/except to handle cases where the bytes are sent instead of the numpy array.
            tmp = frame.shape
            print("Encoding frame as jpeg")
            frame = cv2.imencode(".jpeg", frame)[1].tostring()
        except Exception as e:
            print("{!s}".format(e))
        finally:   
            req.frame.img = frame
        if frame_meta:
            req.frame_num = frame_meta.get("frame_num", -1)
            req.timestamp = frame_meta.get("timestamp", -1)
        return self.ProcessVideoFrame(req)

    def multiprocess_frame(self, req, data, frame_meta=None):
        # data.results.append(self.process_frame(frame, frame_meta))
        res = self.ProcessVideoFrame(req)
        if res.frame.frame.ByteSize() == 0:
            res.frame.frame.img =  req.frame.img
        data.results.append(res)
        

class AnalyticMultiClient:
    def __init__(self):
        self.clients = []

    def connect(self, addr):
        self.addr = addr
        for a in addr:
            self.clients.append(AnalyticClient(addr=a))
    
    def process_frame(self, frame, frame_req, resp, frame_meta=None):
        """ Send frame to all analytics"""
        # resp = analytic_pb2.CompositeResults()
        threads = []
        req = analytic_pb2.InputFrame()
        req.frame.img = cv2.imencode(".jpeg", frame)[1].tostring()
        for a in frame_req.analytics:
            if frame_meta:
                req.frame_num = frame_meta.get("frame_num", -1)
                req.timestamp = frame_meta.get("timestamp", -1)
            req.analytic.MergeFrom(a)
            c = AnalyticClient(addr=a.addr)
            t = threading.Thread(target=c.multiprocess_frame, kwargs=dict(req=req, data=resp))
            t.start()
            threads.append(t)
        
        for t in threads:
            t.join()
        return resp

class FrameServer:
    def __init__(self, addr):
        self.addr = addr
        self.port = int(self.addr.split(":")[-1])

    def serve(self, cap):
        """Function to serve a stream of video frames from an OpenCV capture object"""
        addr = []
        client = AnalyticMultiClient()
        def process(req, resp):
            ret, frame = cap.read()
            if not ret:
                raise ValueError("No frame returned from stream")

            resp = client.process_frame(frame, req, resp)
        
        if not cap or not cap.isOpened():
            logging.error("Unable to open video capture.")
            return
        
        svc = analyticservice.AnalyticService()
        svc.register_name("Frame Server")
        svc.RegisterGetFrame(process)
        logging.info("Registered function with 'GetFrame' endpoint")
        try:
            svc.Run(analytic_port=self.port)
        finally:
            cap.release()
        return

class AceDB:
    def __init__(self, host="localhost", port=8086, db_name="ace"):
        try:
            self.client = InfluxDBClient(host=host, port=port, database="ace")
            self.initialize_db(db_name)
        except requests.exceptions.ConnectionError:
            raise ValueError("Unable to connect to database")

    def initialize_db(self, db_name='ace'):
        self.client.create_database(db_name)
        self.db_name = db_name

    def write(self, **kwargs):
        data = self.build_json(kwargs)
        self._write(data)

    def _write(self, data):
        if not self.db_name:
            raise ValueError("No database initialized")
        self.client.write_points(data)

    def build_json(self, d):
        data = {
            "measurement": "confidence",
            "tags": {
                "analytic": d["analytic"]
             },
            "fields": {
                "confidence": d["score"],
                "classification": d["classification"]
             }
        }
        data["fields"].update(d["filters"])
        print(data)
        return [data]







