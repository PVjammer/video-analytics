#!/bin/python

import cv2
import click
import functools
import grpc
import json
import uuid
import sys
import numpy as np
import logging

from grpc_health.v1 import health_pb2
from grpc_health.v1 import health_pb2_grpc
from google.protobuf import json_format

from ace import aceclient, analytic_pb2, analyticservice
from ace.utils import render
# import aceclient, analytic_pb2, analyticservice

class Context:
    pass

def _rpc_error_leaf_nodes(rpc_error):
    def _find_leaves(debug_info):
        errs = debug_info.get('referenced_errors')
        if debug_info is None or errs is None:
            yield debug_info
            return

        for e in errs:
            yield from _find_leaves(e)

    debug_info = json.loads(rpc_error.debug_error_string())
    yield from _find_leaves(debug_info)

def friendly_rpc_errors(f):
    @functools.wraps(f)
    def wrapper(*args, **kargs):
        try:
            f(*args, **kargs)
        except grpc.RpcError as e:
            print("RPC_ERROR ({code}) {detail}:".format(code=e.code(), detail=e.details()), file=sys.stderr)
            for root_cause in _rpc_error_leaf_nodes(e):
                print(json.dumps(root_cause, sort_keys=True, indent=2), file=sys.stderr)
            return
    return wrapper

@click.group()
@click.option("--db_addr", "-d", default=None, help="Address of the database to connect to")
@click.pass_context
def main(ctx, db_addr):
    ctx.ensure_object(Context)
    ctx.obj.client = aceclient.AceClient()
    ctx.obj.db = None #"Unimplemented"
    if db_addr:
        addr_list = db_addr.split(":")
        if len(addr_list) != 2:
            raise ValueError("Address must be of the form <host>:<port>")
        print("Connecting to database. Host: {!s} Port: {!s}".format(addr_list[0], addr_list[1]))
        ctx.obj.db = aceclient.AceDB(host=addr_list[0], port=addr_list[1])
    print(ctx.obj.db)


@main.command()
@click.pass_context
@click.option("--analytic_addr", "-a", default=[], multiple=True, help="Address of the analytic to process the stream.")
@click.option("--host", "-h", default="localhost", help="Host IP that the stream processer is running on")
@click.option("--port", "-p", default="50052", help="Host IP that the stream processer is running on")
def run(ctx, host, port, analytic_addr):
    """Start a stream from the specified streamer to one or more analytics registered to that streamer"""
    addr = "{!s}:{!s}".format(host, port)
    if not analytic_addr:
        analytic_addr = ["localhost:50051"]
    client = aceclient.AnalyticClient(addr=addr)
    req = analytic_pb2.FrameRequest()
    for a in analytic_addr:
        analytic = analytic_pb2.AnalyticData()
        analytic.addr = a
        req.analytics.append(analytic)
    classes = {}
    window_names = []
    # cv2.namedWindow(window_names[0])
    try:
        while True:
            resp = client.GetFrame(req)
            frame = np.zeros(1)
            render(resp, window_names, classes, frame)
    finally:
        cv2.destroyAllWindows()
        print("Shutting down")

#TODO: command arg for handling file path type (ex. mp4, avi)
#TODO: within click decide is path exists in option type
@main.group()
@click.option("--host", "-h", default="localhost", help="Host the service runs listens on.")
@click.option("--port", "-p", default="50052", help="Port the service runs listens on.")
@click.pass_context
def serve(ctx, host, port):
    addr = "{!s}:{!s}".format(host, port)
    ctx.obj.client.server = aceclient.FrameServer(addr)

@serve.command()
@click.pass_context
@click.option("--camera_id", "-c", default=0, help="ID of the camera on the host machine from which to stream video.")
@click.option("--port", "-p", default=50052, help="Port on which the streamer will run.")
def camera(ctx, camera_id, port):
    """Servestream runs a grpc server which, when requested, will stream frames from the camera (camera_id) to the specified 
    analytic (analytic_addr), and returns the annotated frame with metadata."""

    server = ctx.obj.client.server
    cap = cv2.VideoCapture(int(camera_id))
    server.serve(cap)

@serve.command()
@click.pass_context
@click.option("--videofile", "-v", default=None, help='Path to video file being processed.', type=click.Path())
@click.option("--port", "-p", default=50052, help="Port on which the streamer will run.")
def video(ctx, videofile, port):
    """Servestream runs a grpc server which, when requested, will stream frames from the camera (camera_id) to the specified 
    analytic (analytic_addr), and returns the annotated frame with metadata."""

    server = ctx.obj.client.server
    cap = cv2.VideoCapture(videofile)
    server.serve(cap)
    

@main.group()
@click.pass_context
def stream(ctx):
    print(ctx.obj.db)
    pass

@stream.command()
@click.option('--video-file', '-v', help='Path to video file being processed.', type=click.Path())
@click.option("--analytic_addr", "-a", default=[], multiple=True, help="Address of the analytic to process the stream.")
@click.pass_context
def video(ctx, video_file, analytic_addr):
    """Stream the contents of a video file to an analytic"""
    if not analytic_addr:
        analytic_addr = ["localhost:50051"]

    client = aceclient.AnalyticMultiClient()
    classes = {}
    cap = cv2.VideoCapture(video_file)
    window_names = []
    f_req = analytic_pb2.FrameRequest()
    for a in analytic_addr:
        analytic = analytic_pb2.AnalyticData()
        analytic.addr = a
        f_req.analytics.append(analytic)
    try:
        while (cap.isOpened()):
            ret, frame = cap.read()
            resp = analytic_pb2.CompositeResults()
            resp = client.process_frame(frame, f_req, resp)
            render(resp, window_names, classes, frame)
    finally:
        cv2.destroyAllWindows()
        print("Shutting down")

@stream.command()
@click.option("--analytic_addr", "-a", default=[], multiple=True, help="Address of the analytic to process the stream.")
@click.option('--cam_id', '-c', default=0, help="The numerical identifier for the camera/webcam.  Default is 0.")
@click.pass_context
def camera(ctx, cam_id, analytic_addr):
    """Stream the live camera feed from "cam_id" to an analytic"""
    if not analytic_addr:
        analytic_addr = ["localhost:50051"]
    ###
    db = ctx.obj.db
    ###
    client = aceclient.AnalyticMultiClient()
    cap = cv2.VideoCapture(int(cam_id))
    classes = {}
    window_names = []
    f_req = analytic_pb2.FrameRequest()
    for a in analytic_addr:
        analytic = analytic_pb2.AnalyticData()
        analytic.addr = a
        f_req.analytics.append(analytic)
    try:
        while cap.isOpened():
            ret, frame = cap.read()
            if not ret:
                print("Stream unavailable. Exiting.")
                break
            resp = analytic_pb2.CompositeResults()
            resp = client.process_frame(frame, f_req, resp)
            render(resp, window_names, classes, frame, db)
    finally:
        cv2.destroyAllWindows()
        print("Shutting down")

@main.command()
@click.pass_context
@click.option('--cam_id', '-c', default=0, help="The numerical identifier for the camera/webcam.  Default is 0.")
def testcamera(ctx, cam_id):
    """Test that the client is able to access the camera. Displays live feed from specified camera"""
    client = ctx.obj.client
    cap = cv2.VideoCapture(cam_id)
    frame_num = 1
    classes = {}
    try:
        while True:
            ret, frame = cap.read()
            if not ret:
                print("Stream unavailable. Exiting.")
                break

            cv2.imshow('Camera Feed', frame)
            if cv2.waitKey(1) & 0xFF == ord('q'):
                break
            frame_num += 1
    except:
        pass

    cap.release()
    cv2.destroyAllWindows()

@main.command()
@click.pass_context
@click.option("--analytic_addr", "-a", default=[], multiple=True, help="Address of the analytic to process the stream.")
@click.option('--cam_id', '-c', default=0, help="The numerical identifier for the camera/webcam.  Default is 0.")
@click.option("--alert", multiple=True, help="Classifications to be alerted for (filtered as an 'OR')")
@click.option("--showframes", "-f", default=10, help="Number of frames to show after an alert is triggered")
def alertdemo(ctx, alert, analytic_addr, cam_id, showframes):
    if not analytic_addr:
        analytic_addr = ["localhost:50051"]

    client = aceclient.AnalyticMultiClient()
    cap = cv2.VideoCapture(int(cam_id))
    classes = {}
    window_names = []
    show_counter = 0
    f_req = analytic_pb2.FrameRequest()
    for a in analytic_addr:
        analytic = analytic_pb2.AnalyticData()
        analytic.addr = a
        f_req.analytics.append(analytic)
    try:
        while cap.isOpened():
            ret, frame = cap.read()
            if not ret:
                print("Stream unavailable. Exiting.")
                break
            resp = analytic_pb2.CompositeResults()
            resp = client.process_frame(frame, f_req, resp)
            for i, res in enumerate(resp.results):
                window_name = "{!s}: {!s}".format(res.analytic.name, get_operations(res.analytic.operations))
                if window_name not in window_names:
                    cv2.namedWindow(window_name)
                    window_names.append(window_name)
                data = res.data
                if res.frame.frame.ByteSize() > 0:
                    img_bytes = np.fromstring(res.frame.frame.img, dtype=np.uint8)
                    frame = cv2.imdecode(img_bytes,1)
                color_counter = 0
                show = False
                for roi in data.roi:
                    if roi.HasField("box"):
                        box = roi.box
                        if roi.classification not in classes:
                            print("Adding '{!s}' to classification dict".format(roi.classification))
                            classes[roi.classification] = color_counter % len(colors)
                            color_counter += 1
                        if roi.classification.lower() in alert:
                            cv2.rectangle(frame, (box.corner1.x, box.corner1.y), (box.corner2.x, box.corner2.y), colors[classes[roi.classification]], 2) 
                            cv2.putText(frame, roi.classification, (box.corner1.x, box.corner1.y), cv2.FONT_HERSHEY_COMPLEX, 1, (255, 255, 0))
                            show = True
                            show_counter = int(showframes)
                if show_counter > 0:
                    show = True
                    show_counter -= 1
                if show:    
                    cv2.imshow(window_name, frame)
                    if cv2.waitKey(1) & 0xFF == ord('q'):
                        break
                else:
                    cv2.destroyAllWindows()    
    finally:
        cv2.destroyAllWindows()
        print("Shutting down")


if __name__ == '__main__':
    main(obj=Context())
